// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: support.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_support_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_support_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_support_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_support_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[13]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_support_2eproto;
class binary_blob;
class binary_blobDefaultTypeInternal;
extern binary_blobDefaultTypeInternal _binary_blob_default_instance_;
class curve_parameters_message;
class curve_parameters_messageDefaultTypeInternal;
extern curve_parameters_messageDefaultTypeInternal _curve_parameters_message_default_instance_;
class ecc_parameters_message;
class ecc_parameters_messageDefaultTypeInternal;
extern ecc_parameters_messageDefaultTypeInternal _ecc_parameters_message_default_instance_;
class ecc_private_parameters_message;
class ecc_private_parameters_messageDefaultTypeInternal;
extern ecc_private_parameters_messageDefaultTypeInternal _ecc_private_parameters_message_default_instance_;
class ecc_public_parameters_message;
class ecc_public_parameters_messageDefaultTypeInternal;
extern ecc_public_parameters_messageDefaultTypeInternal _ecc_public_parameters_message_default_instance_;
class encrypted_message;
class encrypted_messageDefaultTypeInternal;
extern encrypted_messageDefaultTypeInternal _encrypted_message_default_instance_;
class hmac_parameters_message;
class hmac_parameters_messageDefaultTypeInternal;
extern hmac_parameters_messageDefaultTypeInternal _hmac_parameters_message_default_instance_;
class key_message;
class key_messageDefaultTypeInternal;
extern key_messageDefaultTypeInternal _key_message_default_instance_;
class rsa_parameters_message;
class rsa_parameters_messageDefaultTypeInternal;
extern rsa_parameters_messageDefaultTypeInternal _rsa_parameters_message_default_instance_;
class rsa_private_parameters_message;
class rsa_private_parameters_messageDefaultTypeInternal;
extern rsa_private_parameters_messageDefaultTypeInternal _rsa_private_parameters_message_default_instance_;
class rsa_public_parameters_message;
class rsa_public_parameters_messageDefaultTypeInternal;
extern rsa_public_parameters_messageDefaultTypeInternal _rsa_public_parameters_message_default_instance_;
class scheme_message;
class scheme_messageDefaultTypeInternal;
extern scheme_messageDefaultTypeInternal _scheme_message_default_instance_;
class signature_message;
class signature_messageDefaultTypeInternal;
extern signature_messageDefaultTypeInternal _signature_message_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::binary_blob* Arena::CreateMaybeMessage<::binary_blob>(Arena*);
template<> ::curve_parameters_message* Arena::CreateMaybeMessage<::curve_parameters_message>(Arena*);
template<> ::ecc_parameters_message* Arena::CreateMaybeMessage<::ecc_parameters_message>(Arena*);
template<> ::ecc_private_parameters_message* Arena::CreateMaybeMessage<::ecc_private_parameters_message>(Arena*);
template<> ::ecc_public_parameters_message* Arena::CreateMaybeMessage<::ecc_public_parameters_message>(Arena*);
template<> ::encrypted_message* Arena::CreateMaybeMessage<::encrypted_message>(Arena*);
template<> ::hmac_parameters_message* Arena::CreateMaybeMessage<::hmac_parameters_message>(Arena*);
template<> ::key_message* Arena::CreateMaybeMessage<::key_message>(Arena*);
template<> ::rsa_parameters_message* Arena::CreateMaybeMessage<::rsa_parameters_message>(Arena*);
template<> ::rsa_private_parameters_message* Arena::CreateMaybeMessage<::rsa_private_parameters_message>(Arena*);
template<> ::rsa_public_parameters_message* Arena::CreateMaybeMessage<::rsa_public_parameters_message>(Arena*);
template<> ::scheme_message* Arena::CreateMaybeMessage<::scheme_message>(Arena*);
template<> ::signature_message* Arena::CreateMaybeMessage<::signature_message>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class binary_blob PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:binary_blob) */ {
 public:
  inline binary_blob() : binary_blob(nullptr) {};
  virtual ~binary_blob();

  binary_blob(const binary_blob& from);
  binary_blob(binary_blob&& from) noexcept
    : binary_blob() {
    *this = ::std::move(from);
  }

  inline binary_blob& operator=(const binary_blob& from) {
    CopyFrom(from);
    return *this;
  }
  inline binary_blob& operator=(binary_blob&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const binary_blob& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const binary_blob* internal_default_instance() {
    return reinterpret_cast<const binary_blob*>(
               &_binary_blob_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(binary_blob& a, binary_blob& b) {
    a.Swap(&b);
  }
  inline void Swap(binary_blob* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(binary_blob* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline binary_blob* New() const final {
    return CreateMaybeMessage<binary_blob>(nullptr);
  }

  binary_blob* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<binary_blob>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const binary_blob& from);
  void MergeFrom(const binary_blob& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(binary_blob* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "binary_blob";
  }
  protected:
  explicit binary_blob(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_support_2eproto);
    return ::descriptor_table_support_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlobFieldNumber = 1,
  };
  // optional string blob = 1;
  bool has_blob() const;
  private:
  bool _internal_has_blob() const;
  public:
  void clear_blob();
  const std::string& blob() const;
  void set_blob(const std::string& value);
  void set_blob(std::string&& value);
  void set_blob(const char* value);
  void set_blob(const char* value, size_t size);
  std::string* mutable_blob();
  std::string* release_blob();
  void set_allocated_blob(std::string* blob);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_blob();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_blob(
      std::string* blob);
  private:
  const std::string& _internal_blob() const;
  void _internal_set_blob(const std::string& value);
  std::string* _internal_mutable_blob();
  public:

  // @@protoc_insertion_point(class_scope:binary_blob)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blob_;
  friend struct ::TableStruct_support_2eproto;
};
// -------------------------------------------------------------------

class encrypted_message PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:encrypted_message) */ {
 public:
  inline encrypted_message() : encrypted_message(nullptr) {};
  virtual ~encrypted_message();

  encrypted_message(const encrypted_message& from);
  encrypted_message(encrypted_message&& from) noexcept
    : encrypted_message() {
    *this = ::std::move(from);
  }

  inline encrypted_message& operator=(const encrypted_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline encrypted_message& operator=(encrypted_message&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const encrypted_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const encrypted_message* internal_default_instance() {
    return reinterpret_cast<const encrypted_message*>(
               &_encrypted_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(encrypted_message& a, encrypted_message& b) {
    a.Swap(&b);
  }
  inline void Swap(encrypted_message* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(encrypted_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline encrypted_message* New() const final {
    return CreateMaybeMessage<encrypted_message>(nullptr);
  }

  encrypted_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<encrypted_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const encrypted_message& from);
  void MergeFrom(const encrypted_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(encrypted_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "encrypted_message";
  }
  protected:
  explicit encrypted_message(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_support_2eproto);
    return ::descriptor_table_support_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSchemeIdentifierFieldNumber = 1,
    kMessageIdentifierFieldNumber = 2,
    kSourceFieldNumber = 3,
    kDestinationFieldNumber = 4,
    kDateFieldNumber = 5,
    kBufferFieldNumber = 6,
  };
  // optional string scheme_identifier = 1;
  bool has_scheme_identifier() const;
  private:
  bool _internal_has_scheme_identifier() const;
  public:
  void clear_scheme_identifier();
  const std::string& scheme_identifier() const;
  void set_scheme_identifier(const std::string& value);
  void set_scheme_identifier(std::string&& value);
  void set_scheme_identifier(const char* value);
  void set_scheme_identifier(const char* value, size_t size);
  std::string* mutable_scheme_identifier();
  std::string* release_scheme_identifier();
  void set_allocated_scheme_identifier(std::string* scheme_identifier);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_scheme_identifier();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_scheme_identifier(
      std::string* scheme_identifier);
  private:
  const std::string& _internal_scheme_identifier() const;
  void _internal_set_scheme_identifier(const std::string& value);
  std::string* _internal_mutable_scheme_identifier();
  public:

  // optional string message_identifier = 2;
  bool has_message_identifier() const;
  private:
  bool _internal_has_message_identifier() const;
  public:
  void clear_message_identifier();
  const std::string& message_identifier() const;
  void set_message_identifier(const std::string& value);
  void set_message_identifier(std::string&& value);
  void set_message_identifier(const char* value);
  void set_message_identifier(const char* value, size_t size);
  std::string* mutable_message_identifier();
  std::string* release_message_identifier();
  void set_allocated_message_identifier(std::string* message_identifier);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_message_identifier();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_message_identifier(
      std::string* message_identifier);
  private:
  const std::string& _internal_message_identifier() const;
  void _internal_set_message_identifier(const std::string& value);
  std::string* _internal_mutable_message_identifier();
  public:

  // optional string source = 3;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const std::string& source() const;
  void set_source(const std::string& value);
  void set_source(std::string&& value);
  void set_source(const char* value);
  void set_source(const char* value, size_t size);
  std::string* mutable_source();
  std::string* release_source();
  void set_allocated_source(std::string* source);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_source();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_source(
      std::string* source);
  private:
  const std::string& _internal_source() const;
  void _internal_set_source(const std::string& value);
  std::string* _internal_mutable_source();
  public:

  // optional string destination = 4;
  bool has_destination() const;
  private:
  bool _internal_has_destination() const;
  public:
  void clear_destination();
  const std::string& destination() const;
  void set_destination(const std::string& value);
  void set_destination(std::string&& value);
  void set_destination(const char* value);
  void set_destination(const char* value, size_t size);
  std::string* mutable_destination();
  std::string* release_destination();
  void set_allocated_destination(std::string* destination);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_destination();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_destination(
      std::string* destination);
  private:
  const std::string& _internal_destination() const;
  void _internal_set_destination(const std::string& value);
  std::string* _internal_mutable_destination();
  public:

  // optional string date = 5;
  bool has_date() const;
  private:
  bool _internal_has_date() const;
  public:
  void clear_date();
  const std::string& date() const;
  void set_date(const std::string& value);
  void set_date(std::string&& value);
  void set_date(const char* value);
  void set_date(const char* value, size_t size);
  std::string* mutable_date();
  std::string* release_date();
  void set_allocated_date(std::string* date);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_date();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_date(
      std::string* date);
  private:
  const std::string& _internal_date() const;
  void _internal_set_date(const std::string& value);
  std::string* _internal_mutable_date();
  public:

  // optional bytes buffer = 6;
  bool has_buffer() const;
  private:
  bool _internal_has_buffer() const;
  public:
  void clear_buffer();
  const std::string& buffer() const;
  void set_buffer(const std::string& value);
  void set_buffer(std::string&& value);
  void set_buffer(const char* value);
  void set_buffer(const void* value, size_t size);
  std::string* mutable_buffer();
  std::string* release_buffer();
  void set_allocated_buffer(std::string* buffer);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_buffer();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_buffer(
      std::string* buffer);
  private:
  const std::string& _internal_buffer() const;
  void _internal_set_buffer(const std::string& value);
  std::string* _internal_mutable_buffer();
  public:

  // @@protoc_insertion_point(class_scope:encrypted_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr scheme_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr date_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buffer_;
  friend struct ::TableStruct_support_2eproto;
};
// -------------------------------------------------------------------

class signature_message PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:signature_message) */ {
 public:
  inline signature_message() : signature_message(nullptr) {};
  virtual ~signature_message();

  signature_message(const signature_message& from);
  signature_message(signature_message&& from) noexcept
    : signature_message() {
    *this = ::std::move(from);
  }

  inline signature_message& operator=(const signature_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline signature_message& operator=(signature_message&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const signature_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const signature_message* internal_default_instance() {
    return reinterpret_cast<const signature_message*>(
               &_signature_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(signature_message& a, signature_message& b) {
    a.Swap(&b);
  }
  inline void Swap(signature_message* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(signature_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline signature_message* New() const final {
    return CreateMaybeMessage<signature_message>(nullptr);
  }

  signature_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<signature_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const signature_message& from);
  void MergeFrom(const signature_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(signature_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "signature_message";
  }
  protected:
  explicit signature_message(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_support_2eproto);
    return ::descriptor_table_support_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:signature_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_support_2eproto;
};
// -------------------------------------------------------------------

class rsa_parameters_message PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rsa_parameters_message) */ {
 public:
  inline rsa_parameters_message() : rsa_parameters_message(nullptr) {};
  virtual ~rsa_parameters_message();

  rsa_parameters_message(const rsa_parameters_message& from);
  rsa_parameters_message(rsa_parameters_message&& from) noexcept
    : rsa_parameters_message() {
    *this = ::std::move(from);
  }

  inline rsa_parameters_message& operator=(const rsa_parameters_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline rsa_parameters_message& operator=(rsa_parameters_message&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const rsa_parameters_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const rsa_parameters_message* internal_default_instance() {
    return reinterpret_cast<const rsa_parameters_message*>(
               &_rsa_parameters_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(rsa_parameters_message& a, rsa_parameters_message& b) {
    a.Swap(&b);
  }
  inline void Swap(rsa_parameters_message* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(rsa_parameters_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline rsa_parameters_message* New() const final {
    return CreateMaybeMessage<rsa_parameters_message>(nullptr);
  }

  rsa_parameters_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<rsa_parameters_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const rsa_parameters_message& from);
  void MergeFrom(const rsa_parameters_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(rsa_parameters_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rsa_parameters_message";
  }
  protected:
  explicit rsa_parameters_message(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_support_2eproto);
    return ::descriptor_table_support_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:rsa_parameters_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_support_2eproto;
};
// -------------------------------------------------------------------

class ecc_parameters_message PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ecc_parameters_message) */ {
 public:
  inline ecc_parameters_message() : ecc_parameters_message(nullptr) {};
  virtual ~ecc_parameters_message();

  ecc_parameters_message(const ecc_parameters_message& from);
  ecc_parameters_message(ecc_parameters_message&& from) noexcept
    : ecc_parameters_message() {
    *this = ::std::move(from);
  }

  inline ecc_parameters_message& operator=(const ecc_parameters_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline ecc_parameters_message& operator=(ecc_parameters_message&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ecc_parameters_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ecc_parameters_message* internal_default_instance() {
    return reinterpret_cast<const ecc_parameters_message*>(
               &_ecc_parameters_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ecc_parameters_message& a, ecc_parameters_message& b) {
    a.Swap(&b);
  }
  inline void Swap(ecc_parameters_message* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ecc_parameters_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ecc_parameters_message* New() const final {
    return CreateMaybeMessage<ecc_parameters_message>(nullptr);
  }

  ecc_parameters_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ecc_parameters_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ecc_parameters_message& from);
  void MergeFrom(const ecc_parameters_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ecc_parameters_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ecc_parameters_message";
  }
  protected:
  explicit ecc_parameters_message(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_support_2eproto);
    return ::descriptor_table_support_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ecc_parameters_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_support_2eproto;
};
// -------------------------------------------------------------------

class rsa_public_parameters_message PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rsa_public_parameters_message) */ {
 public:
  inline rsa_public_parameters_message() : rsa_public_parameters_message(nullptr) {};
  virtual ~rsa_public_parameters_message();

  rsa_public_parameters_message(const rsa_public_parameters_message& from);
  rsa_public_parameters_message(rsa_public_parameters_message&& from) noexcept
    : rsa_public_parameters_message() {
    *this = ::std::move(from);
  }

  inline rsa_public_parameters_message& operator=(const rsa_public_parameters_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline rsa_public_parameters_message& operator=(rsa_public_parameters_message&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const rsa_public_parameters_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const rsa_public_parameters_message* internal_default_instance() {
    return reinterpret_cast<const rsa_public_parameters_message*>(
               &_rsa_public_parameters_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(rsa_public_parameters_message& a, rsa_public_parameters_message& b) {
    a.Swap(&b);
  }
  inline void Swap(rsa_public_parameters_message* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(rsa_public_parameters_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline rsa_public_parameters_message* New() const final {
    return CreateMaybeMessage<rsa_public_parameters_message>(nullptr);
  }

  rsa_public_parameters_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<rsa_public_parameters_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const rsa_public_parameters_message& from);
  void MergeFrom(const rsa_public_parameters_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(rsa_public_parameters_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rsa_public_parameters_message";
  }
  protected:
  explicit rsa_public_parameters_message(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_support_2eproto);
    return ::descriptor_table_support_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModulusFieldNumber = 1,
    kExponentFieldNumber = 2,
  };
  // optional bytes modulus = 1;
  bool has_modulus() const;
  private:
  bool _internal_has_modulus() const;
  public:
  void clear_modulus();
  const std::string& modulus() const;
  void set_modulus(const std::string& value);
  void set_modulus(std::string&& value);
  void set_modulus(const char* value);
  void set_modulus(const void* value, size_t size);
  std::string* mutable_modulus();
  std::string* release_modulus();
  void set_allocated_modulus(std::string* modulus);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_modulus();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_modulus(
      std::string* modulus);
  private:
  const std::string& _internal_modulus() const;
  void _internal_set_modulus(const std::string& value);
  std::string* _internal_mutable_modulus();
  public:

  // optional bytes exponent = 2;
  bool has_exponent() const;
  private:
  bool _internal_has_exponent() const;
  public:
  void clear_exponent();
  const std::string& exponent() const;
  void set_exponent(const std::string& value);
  void set_exponent(std::string&& value);
  void set_exponent(const char* value);
  void set_exponent(const void* value, size_t size);
  std::string* mutable_exponent();
  std::string* release_exponent();
  void set_allocated_exponent(std::string* exponent);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_exponent();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_exponent(
      std::string* exponent);
  private:
  const std::string& _internal_exponent() const;
  void _internal_set_exponent(const std::string& value);
  std::string* _internal_mutable_exponent();
  public:

  // @@protoc_insertion_point(class_scope:rsa_public_parameters_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modulus_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exponent_;
  friend struct ::TableStruct_support_2eproto;
};
// -------------------------------------------------------------------

class ecc_public_parameters_message PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ecc_public_parameters_message) */ {
 public:
  inline ecc_public_parameters_message() : ecc_public_parameters_message(nullptr) {};
  virtual ~ecc_public_parameters_message();

  ecc_public_parameters_message(const ecc_public_parameters_message& from);
  ecc_public_parameters_message(ecc_public_parameters_message&& from) noexcept
    : ecc_public_parameters_message() {
    *this = ::std::move(from);
  }

  inline ecc_public_parameters_message& operator=(const ecc_public_parameters_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline ecc_public_parameters_message& operator=(ecc_public_parameters_message&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ecc_public_parameters_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ecc_public_parameters_message* internal_default_instance() {
    return reinterpret_cast<const ecc_public_parameters_message*>(
               &_ecc_public_parameters_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ecc_public_parameters_message& a, ecc_public_parameters_message& b) {
    a.Swap(&b);
  }
  inline void Swap(ecc_public_parameters_message* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ecc_public_parameters_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ecc_public_parameters_message* New() const final {
    return CreateMaybeMessage<ecc_public_parameters_message>(nullptr);
  }

  ecc_public_parameters_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ecc_public_parameters_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ecc_public_parameters_message& from);
  void MergeFrom(const ecc_public_parameters_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ecc_public_parameters_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ecc_public_parameters_message";
  }
  protected:
  explicit ecc_public_parameters_message(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_support_2eproto);
    return ::descriptor_table_support_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPFieldNumber = 1,
  };
  // optional bytes p = 1;
  bool has_p() const;
  private:
  bool _internal_has_p() const;
  public:
  void clear_p();
  const std::string& p() const;
  void set_p(const std::string& value);
  void set_p(std::string&& value);
  void set_p(const char* value);
  void set_p(const void* value, size_t size);
  std::string* mutable_p();
  std::string* release_p();
  void set_allocated_p(std::string* p);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_p();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_p(
      std::string* p);
  private:
  const std::string& _internal_p() const;
  void _internal_set_p(const std::string& value);
  std::string* _internal_mutable_p();
  public:

  // @@protoc_insertion_point(class_scope:ecc_public_parameters_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr p_;
  friend struct ::TableStruct_support_2eproto;
};
// -------------------------------------------------------------------

class rsa_private_parameters_message PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:rsa_private_parameters_message) */ {
 public:
  inline rsa_private_parameters_message() : rsa_private_parameters_message(nullptr) {};
  virtual ~rsa_private_parameters_message();

  rsa_private_parameters_message(const rsa_private_parameters_message& from);
  rsa_private_parameters_message(rsa_private_parameters_message&& from) noexcept
    : rsa_private_parameters_message() {
    *this = ::std::move(from);
  }

  inline rsa_private_parameters_message& operator=(const rsa_private_parameters_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline rsa_private_parameters_message& operator=(rsa_private_parameters_message&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const rsa_private_parameters_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const rsa_private_parameters_message* internal_default_instance() {
    return reinterpret_cast<const rsa_private_parameters_message*>(
               &_rsa_private_parameters_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(rsa_private_parameters_message& a, rsa_private_parameters_message& b) {
    a.Swap(&b);
  }
  inline void Swap(rsa_private_parameters_message* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(rsa_private_parameters_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline rsa_private_parameters_message* New() const final {
    return CreateMaybeMessage<rsa_private_parameters_message>(nullptr);
  }

  rsa_private_parameters_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<rsa_private_parameters_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const rsa_private_parameters_message& from);
  void MergeFrom(const rsa_private_parameters_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(rsa_private_parameters_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "rsa_private_parameters_message";
  }
  protected:
  explicit rsa_private_parameters_message(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_support_2eproto);
    return ::descriptor_table_support_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:rsa_private_parameters_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_support_2eproto;
};
// -------------------------------------------------------------------

class ecc_private_parameters_message PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ecc_private_parameters_message) */ {
 public:
  inline ecc_private_parameters_message() : ecc_private_parameters_message(nullptr) {};
  virtual ~ecc_private_parameters_message();

  ecc_private_parameters_message(const ecc_private_parameters_message& from);
  ecc_private_parameters_message(ecc_private_parameters_message&& from) noexcept
    : ecc_private_parameters_message() {
    *this = ::std::move(from);
  }

  inline ecc_private_parameters_message& operator=(const ecc_private_parameters_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline ecc_private_parameters_message& operator=(ecc_private_parameters_message&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ecc_private_parameters_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ecc_private_parameters_message* internal_default_instance() {
    return reinterpret_cast<const ecc_private_parameters_message*>(
               &_ecc_private_parameters_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ecc_private_parameters_message& a, ecc_private_parameters_message& b) {
    a.Swap(&b);
  }
  inline void Swap(ecc_private_parameters_message* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ecc_private_parameters_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ecc_private_parameters_message* New() const final {
    return CreateMaybeMessage<ecc_private_parameters_message>(nullptr);
  }

  ecc_private_parameters_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ecc_private_parameters_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ecc_private_parameters_message& from);
  void MergeFrom(const ecc_private_parameters_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ecc_private_parameters_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ecc_private_parameters_message";
  }
  protected:
  explicit ecc_private_parameters_message(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_support_2eproto);
    return ::descriptor_table_support_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ecc_private_parameters_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_support_2eproto;
};
// -------------------------------------------------------------------

class curve_parameters_message PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:curve_parameters_message) */ {
 public:
  inline curve_parameters_message() : curve_parameters_message(nullptr) {};
  virtual ~curve_parameters_message();

  curve_parameters_message(const curve_parameters_message& from);
  curve_parameters_message(curve_parameters_message&& from) noexcept
    : curve_parameters_message() {
    *this = ::std::move(from);
  }

  inline curve_parameters_message& operator=(const curve_parameters_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline curve_parameters_message& operator=(curve_parameters_message&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const curve_parameters_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const curve_parameters_message* internal_default_instance() {
    return reinterpret_cast<const curve_parameters_message*>(
               &_curve_parameters_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(curve_parameters_message& a, curve_parameters_message& b) {
    a.Swap(&b);
  }
  inline void Swap(curve_parameters_message* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(curve_parameters_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline curve_parameters_message* New() const final {
    return CreateMaybeMessage<curve_parameters_message>(nullptr);
  }

  curve_parameters_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<curve_parameters_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const curve_parameters_message& from);
  void MergeFrom(const curve_parameters_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(curve_parameters_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "curve_parameters_message";
  }
  protected:
  explicit curve_parameters_message(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_support_2eproto);
    return ::descriptor_table_support_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:curve_parameters_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_support_2eproto;
};
// -------------------------------------------------------------------

class hmac_parameters_message PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hmac_parameters_message) */ {
 public:
  inline hmac_parameters_message() : hmac_parameters_message(nullptr) {};
  virtual ~hmac_parameters_message();

  hmac_parameters_message(const hmac_parameters_message& from);
  hmac_parameters_message(hmac_parameters_message&& from) noexcept
    : hmac_parameters_message() {
    *this = ::std::move(from);
  }

  inline hmac_parameters_message& operator=(const hmac_parameters_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline hmac_parameters_message& operator=(hmac_parameters_message&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const hmac_parameters_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const hmac_parameters_message* internal_default_instance() {
    return reinterpret_cast<const hmac_parameters_message*>(
               &_hmac_parameters_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(hmac_parameters_message& a, hmac_parameters_message& b) {
    a.Swap(&b);
  }
  inline void Swap(hmac_parameters_message* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(hmac_parameters_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline hmac_parameters_message* New() const final {
    return CreateMaybeMessage<hmac_parameters_message>(nullptr);
  }

  hmac_parameters_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<hmac_parameters_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const hmac_parameters_message& from);
  void MergeFrom(const hmac_parameters_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(hmac_parameters_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hmac_parameters_message";
  }
  protected:
  explicit hmac_parameters_message(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_support_2eproto);
    return ::descriptor_table_support_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAlgorithmFieldNumber = 1,
    kSecretFieldNumber = 3,
    kSizeFieldNumber = 2,
  };
  // optional string algorithm = 1;
  bool has_algorithm() const;
  private:
  bool _internal_has_algorithm() const;
  public:
  void clear_algorithm();
  const std::string& algorithm() const;
  void set_algorithm(const std::string& value);
  void set_algorithm(std::string&& value);
  void set_algorithm(const char* value);
  void set_algorithm(const char* value, size_t size);
  std::string* mutable_algorithm();
  std::string* release_algorithm();
  void set_allocated_algorithm(std::string* algorithm);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_algorithm();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_algorithm(
      std::string* algorithm);
  private:
  const std::string& _internal_algorithm() const;
  void _internal_set_algorithm(const std::string& value);
  std::string* _internal_mutable_algorithm();
  public:

  // optional bytes secret = 3;
  bool has_secret() const;
  private:
  bool _internal_has_secret() const;
  public:
  void clear_secret();
  const std::string& secret() const;
  void set_secret(const std::string& value);
  void set_secret(std::string&& value);
  void set_secret(const char* value);
  void set_secret(const void* value, size_t size);
  std::string* mutable_secret();
  std::string* release_secret();
  void set_allocated_secret(std::string* secret);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_secret();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_secret(
      std::string* secret);
  private:
  const std::string& _internal_secret() const;
  void _internal_set_secret(const std::string& value);
  std::string* _internal_mutable_secret();
  public:

  // optional int32 size = 2;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::int32 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_size() const;
  void _internal_set_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:hmac_parameters_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr algorithm_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_;
  ::PROTOBUF_NAMESPACE_ID::int32 size_;
  friend struct ::TableStruct_support_2eproto;
};
// -------------------------------------------------------------------

class key_message PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:key_message) */ {
 public:
  inline key_message() : key_message(nullptr) {};
  virtual ~key_message();

  key_message(const key_message& from);
  key_message(key_message&& from) noexcept
    : key_message() {
    *this = ::std::move(from);
  }

  inline key_message& operator=(const key_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline key_message& operator=(key_message&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const key_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const key_message* internal_default_instance() {
    return reinterpret_cast<const key_message*>(
               &_key_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(key_message& a, key_message& b) {
    a.Swap(&b);
  }
  inline void Swap(key_message* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(key_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline key_message* New() const final {
    return CreateMaybeMessage<key_message>(nullptr);
  }

  key_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<key_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const key_message& from);
  void MergeFrom(const key_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(key_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "key_message";
  }
  protected:
  explicit key_message(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_support_2eproto);
    return ::descriptor_table_support_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAlgorithmTypeFieldNumber = 1,
    kKeyNameFieldNumber = 2,
    kPurposeFieldNumber = 4,
    kNotBeforeFieldNumber = 5,
    kNotAfterFieldNumber = 6,
    kSecretFieldNumber = 7,
    kKeySizeFieldNumber = 3,
  };
  // optional string algorithm_type = 1;
  bool has_algorithm_type() const;
  private:
  bool _internal_has_algorithm_type() const;
  public:
  void clear_algorithm_type();
  const std::string& algorithm_type() const;
  void set_algorithm_type(const std::string& value);
  void set_algorithm_type(std::string&& value);
  void set_algorithm_type(const char* value);
  void set_algorithm_type(const char* value, size_t size);
  std::string* mutable_algorithm_type();
  std::string* release_algorithm_type();
  void set_allocated_algorithm_type(std::string* algorithm_type);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_algorithm_type();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_algorithm_type(
      std::string* algorithm_type);
  private:
  const std::string& _internal_algorithm_type() const;
  void _internal_set_algorithm_type(const std::string& value);
  std::string* _internal_mutable_algorithm_type();
  public:

  // optional string key_name = 2;
  bool has_key_name() const;
  private:
  bool _internal_has_key_name() const;
  public:
  void clear_key_name();
  const std::string& key_name() const;
  void set_key_name(const std::string& value);
  void set_key_name(std::string&& value);
  void set_key_name(const char* value);
  void set_key_name(const char* value, size_t size);
  std::string* mutable_key_name();
  std::string* release_key_name();
  void set_allocated_key_name(std::string* key_name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_key_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_key_name(
      std::string* key_name);
  private:
  const std::string& _internal_key_name() const;
  void _internal_set_key_name(const std::string& value);
  std::string* _internal_mutable_key_name();
  public:

  // optional string purpose = 4;
  bool has_purpose() const;
  private:
  bool _internal_has_purpose() const;
  public:
  void clear_purpose();
  const std::string& purpose() const;
  void set_purpose(const std::string& value);
  void set_purpose(std::string&& value);
  void set_purpose(const char* value);
  void set_purpose(const char* value, size_t size);
  std::string* mutable_purpose();
  std::string* release_purpose();
  void set_allocated_purpose(std::string* purpose);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_purpose();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_purpose(
      std::string* purpose);
  private:
  const std::string& _internal_purpose() const;
  void _internal_set_purpose(const std::string& value);
  std::string* _internal_mutable_purpose();
  public:

  // optional string notBefore = 5;
  bool has_notbefore() const;
  private:
  bool _internal_has_notbefore() const;
  public:
  void clear_notbefore();
  const std::string& notbefore() const;
  void set_notbefore(const std::string& value);
  void set_notbefore(std::string&& value);
  void set_notbefore(const char* value);
  void set_notbefore(const char* value, size_t size);
  std::string* mutable_notbefore();
  std::string* release_notbefore();
  void set_allocated_notbefore(std::string* notbefore);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_notbefore();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_notbefore(
      std::string* notbefore);
  private:
  const std::string& _internal_notbefore() const;
  void _internal_set_notbefore(const std::string& value);
  std::string* _internal_mutable_notbefore();
  public:

  // optional string notAfter = 6;
  bool has_notafter() const;
  private:
  bool _internal_has_notafter() const;
  public:
  void clear_notafter();
  const std::string& notafter() const;
  void set_notafter(const std::string& value);
  void set_notafter(std::string&& value);
  void set_notafter(const char* value);
  void set_notafter(const char* value, size_t size);
  std::string* mutable_notafter();
  std::string* release_notafter();
  void set_allocated_notafter(std::string* notafter);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_notafter();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_notafter(
      std::string* notafter);
  private:
  const std::string& _internal_notafter() const;
  void _internal_set_notafter(const std::string& value);
  std::string* _internal_mutable_notafter();
  public:

  // optional bytes secret = 7;
  bool has_secret() const;
  private:
  bool _internal_has_secret() const;
  public:
  void clear_secret();
  const std::string& secret() const;
  void set_secret(const std::string& value);
  void set_secret(std::string&& value);
  void set_secret(const char* value);
  void set_secret(const void* value, size_t size);
  std::string* mutable_secret();
  std::string* release_secret();
  void set_allocated_secret(std::string* secret);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_secret();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_secret(
      std::string* secret);
  private:
  const std::string& _internal_secret() const;
  void _internal_set_secret(const std::string& value);
  std::string* _internal_mutable_secret();
  public:

  // optional int32 key_size = 3;
  bool has_key_size() const;
  private:
  bool _internal_has_key_size() const;
  public:
  void clear_key_size();
  ::PROTOBUF_NAMESPACE_ID::int32 key_size() const;
  void set_key_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_key_size() const;
  void _internal_set_key_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:key_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr algorithm_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr purpose_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr notbefore_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr notafter_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_;
  ::PROTOBUF_NAMESPACE_ID::int32 key_size_;
  friend struct ::TableStruct_support_2eproto;
};
// -------------------------------------------------------------------

class scheme_message PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:scheme_message) */ {
 public:
  inline scheme_message() : scheme_message(nullptr) {};
  virtual ~scheme_message();

  scheme_message(const scheme_message& from);
  scheme_message(scheme_message&& from) noexcept
    : scheme_message() {
    *this = ::std::move(from);
  }

  inline scheme_message& operator=(const scheme_message& from) {
    CopyFrom(from);
    return *this;
  }
  inline scheme_message& operator=(scheme_message&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const scheme_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const scheme_message* internal_default_instance() {
    return reinterpret_cast<const scheme_message*>(
               &_scheme_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(scheme_message& a, scheme_message& b) {
    a.Swap(&b);
  }
  inline void Swap(scheme_message* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(scheme_message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline scheme_message* New() const final {
    return CreateMaybeMessage<scheme_message>(nullptr);
  }

  scheme_message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<scheme_message>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const scheme_message& from);
  void MergeFrom(const scheme_message& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(scheme_message* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "scheme_message";
  }
  protected:
  explicit scheme_message(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_support_2eproto);
    return ::descriptor_table_support_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSchemeTypeFieldNumber = 1,
    kPublicNonceFieldNumber = 4,
    kEncryptionKeyFieldNumber = 2,
    kParametersFieldNumber = 3,
  };
  // optional string scheme_type = 1;
  bool has_scheme_type() const;
  private:
  bool _internal_has_scheme_type() const;
  public:
  void clear_scheme_type();
  const std::string& scheme_type() const;
  void set_scheme_type(const std::string& value);
  void set_scheme_type(std::string&& value);
  void set_scheme_type(const char* value);
  void set_scheme_type(const char* value, size_t size);
  std::string* mutable_scheme_type();
  std::string* release_scheme_type();
  void set_allocated_scheme_type(std::string* scheme_type);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_scheme_type();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_scheme_type(
      std::string* scheme_type);
  private:
  const std::string& _internal_scheme_type() const;
  void _internal_set_scheme_type(const std::string& value);
  std::string* _internal_mutable_scheme_type();
  public:

  // optional bytes public_nonce = 4;
  bool has_public_nonce() const;
  private:
  bool _internal_has_public_nonce() const;
  public:
  void clear_public_nonce();
  const std::string& public_nonce() const;
  void set_public_nonce(const std::string& value);
  void set_public_nonce(std::string&& value);
  void set_public_nonce(const char* value);
  void set_public_nonce(const void* value, size_t size);
  std::string* mutable_public_nonce();
  std::string* release_public_nonce();
  void set_allocated_public_nonce(std::string* public_nonce);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_public_nonce();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_public_nonce(
      std::string* public_nonce);
  private:
  const std::string& _internal_public_nonce() const;
  void _internal_set_public_nonce(const std::string& value);
  std::string* _internal_mutable_public_nonce();
  public:

  // optional .key_message encryption_key = 2;
  bool has_encryption_key() const;
  private:
  bool _internal_has_encryption_key() const;
  public:
  void clear_encryption_key();
  const ::key_message& encryption_key() const;
  ::key_message* release_encryption_key();
  ::key_message* mutable_encryption_key();
  void set_allocated_encryption_key(::key_message* encryption_key);
  private:
  const ::key_message& _internal_encryption_key() const;
  ::key_message* _internal_mutable_encryption_key();
  public:
  void unsafe_arena_set_allocated_encryption_key(
      ::key_message* encryption_key);
  ::key_message* unsafe_arena_release_encryption_key();

  // optional .hmac_parameters_message parameters = 3;
  bool has_parameters() const;
  private:
  bool _internal_has_parameters() const;
  public:
  void clear_parameters();
  const ::hmac_parameters_message& parameters() const;
  ::hmac_parameters_message* release_parameters();
  ::hmac_parameters_message* mutable_parameters();
  void set_allocated_parameters(::hmac_parameters_message* parameters);
  private:
  const ::hmac_parameters_message& _internal_parameters() const;
  ::hmac_parameters_message* _internal_mutable_parameters();
  public:
  void unsafe_arena_set_allocated_parameters(
      ::hmac_parameters_message* parameters);
  ::hmac_parameters_message* unsafe_arena_release_parameters();

  // @@protoc_insertion_point(class_scope:scheme_message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr scheme_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_nonce_;
  ::key_message* encryption_key_;
  ::hmac_parameters_message* parameters_;
  friend struct ::TableStruct_support_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// binary_blob

// optional string blob = 1;
inline bool binary_blob::_internal_has_blob() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool binary_blob::has_blob() const {
  return _internal_has_blob();
}
inline void binary_blob::clear_blob() {
  blob_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& binary_blob::blob() const {
  // @@protoc_insertion_point(field_get:binary_blob.blob)
  return _internal_blob();
}
inline void binary_blob::set_blob(const std::string& value) {
  _internal_set_blob(value);
  // @@protoc_insertion_point(field_set:binary_blob.blob)
}
inline std::string* binary_blob::mutable_blob() {
  // @@protoc_insertion_point(field_mutable:binary_blob.blob)
  return _internal_mutable_blob();
}
inline const std::string& binary_blob::_internal_blob() const {
  return blob_.Get();
}
inline void binary_blob::_internal_set_blob(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  blob_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void binary_blob::set_blob(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  blob_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:binary_blob.blob)
}
inline void binary_blob::set_blob(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  blob_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:binary_blob.blob)
}
inline void binary_blob::set_blob(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  blob_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:binary_blob.blob)
}
inline std::string* binary_blob::_internal_mutable_blob() {
  _has_bits_[0] |= 0x00000001u;
  return blob_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* binary_blob::release_blob() {
  // @@protoc_insertion_point(field_release:binary_blob.blob)
  if (!_internal_has_blob()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return blob_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void binary_blob::set_allocated_blob(std::string* blob) {
  if (blob != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  blob_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), blob,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:binary_blob.blob)
}
inline std::string* binary_blob::unsafe_arena_release_blob() {
  // @@protoc_insertion_point(field_unsafe_arena_release:binary_blob.blob)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return blob_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void binary_blob::unsafe_arena_set_allocated_blob(
    std::string* blob) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (blob != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  blob_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      blob, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:binary_blob.blob)
}

// -------------------------------------------------------------------

// encrypted_message

// optional string scheme_identifier = 1;
inline bool encrypted_message::_internal_has_scheme_identifier() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool encrypted_message::has_scheme_identifier() const {
  return _internal_has_scheme_identifier();
}
inline void encrypted_message::clear_scheme_identifier() {
  scheme_identifier_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& encrypted_message::scheme_identifier() const {
  // @@protoc_insertion_point(field_get:encrypted_message.scheme_identifier)
  return _internal_scheme_identifier();
}
inline void encrypted_message::set_scheme_identifier(const std::string& value) {
  _internal_set_scheme_identifier(value);
  // @@protoc_insertion_point(field_set:encrypted_message.scheme_identifier)
}
inline std::string* encrypted_message::mutable_scheme_identifier() {
  // @@protoc_insertion_point(field_mutable:encrypted_message.scheme_identifier)
  return _internal_mutable_scheme_identifier();
}
inline const std::string& encrypted_message::_internal_scheme_identifier() const {
  return scheme_identifier_.Get();
}
inline void encrypted_message::_internal_set_scheme_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  scheme_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void encrypted_message::set_scheme_identifier(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  scheme_identifier_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:encrypted_message.scheme_identifier)
}
inline void encrypted_message::set_scheme_identifier(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  scheme_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:encrypted_message.scheme_identifier)
}
inline void encrypted_message::set_scheme_identifier(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  scheme_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:encrypted_message.scheme_identifier)
}
inline std::string* encrypted_message::_internal_mutable_scheme_identifier() {
  _has_bits_[0] |= 0x00000001u;
  return scheme_identifier_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* encrypted_message::release_scheme_identifier() {
  // @@protoc_insertion_point(field_release:encrypted_message.scheme_identifier)
  if (!_internal_has_scheme_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return scheme_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void encrypted_message::set_allocated_scheme_identifier(std::string* scheme_identifier) {
  if (scheme_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  scheme_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), scheme_identifier,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:encrypted_message.scheme_identifier)
}
inline std::string* encrypted_message::unsafe_arena_release_scheme_identifier() {
  // @@protoc_insertion_point(field_unsafe_arena_release:encrypted_message.scheme_identifier)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return scheme_identifier_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void encrypted_message::unsafe_arena_set_allocated_scheme_identifier(
    std::string* scheme_identifier) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (scheme_identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  scheme_identifier_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      scheme_identifier, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:encrypted_message.scheme_identifier)
}

// optional string message_identifier = 2;
inline bool encrypted_message::_internal_has_message_identifier() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool encrypted_message::has_message_identifier() const {
  return _internal_has_message_identifier();
}
inline void encrypted_message::clear_message_identifier() {
  message_identifier_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& encrypted_message::message_identifier() const {
  // @@protoc_insertion_point(field_get:encrypted_message.message_identifier)
  return _internal_message_identifier();
}
inline void encrypted_message::set_message_identifier(const std::string& value) {
  _internal_set_message_identifier(value);
  // @@protoc_insertion_point(field_set:encrypted_message.message_identifier)
}
inline std::string* encrypted_message::mutable_message_identifier() {
  // @@protoc_insertion_point(field_mutable:encrypted_message.message_identifier)
  return _internal_mutable_message_identifier();
}
inline const std::string& encrypted_message::_internal_message_identifier() const {
  return message_identifier_.Get();
}
inline void encrypted_message::_internal_set_message_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  message_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void encrypted_message::set_message_identifier(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  message_identifier_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:encrypted_message.message_identifier)
}
inline void encrypted_message::set_message_identifier(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  message_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:encrypted_message.message_identifier)
}
inline void encrypted_message::set_message_identifier(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  message_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:encrypted_message.message_identifier)
}
inline std::string* encrypted_message::_internal_mutable_message_identifier() {
  _has_bits_[0] |= 0x00000002u;
  return message_identifier_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* encrypted_message::release_message_identifier() {
  // @@protoc_insertion_point(field_release:encrypted_message.message_identifier)
  if (!_internal_has_message_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return message_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void encrypted_message::set_allocated_message_identifier(std::string* message_identifier) {
  if (message_identifier != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  message_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message_identifier,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:encrypted_message.message_identifier)
}
inline std::string* encrypted_message::unsafe_arena_release_message_identifier() {
  // @@protoc_insertion_point(field_unsafe_arena_release:encrypted_message.message_identifier)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return message_identifier_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void encrypted_message::unsafe_arena_set_allocated_message_identifier(
    std::string* message_identifier) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (message_identifier != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  message_identifier_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      message_identifier, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:encrypted_message.message_identifier)
}

// optional string source = 3;
inline bool encrypted_message::_internal_has_source() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool encrypted_message::has_source() const {
  return _internal_has_source();
}
inline void encrypted_message::clear_source() {
  source_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& encrypted_message::source() const {
  // @@protoc_insertion_point(field_get:encrypted_message.source)
  return _internal_source();
}
inline void encrypted_message::set_source(const std::string& value) {
  _internal_set_source(value);
  // @@protoc_insertion_point(field_set:encrypted_message.source)
}
inline std::string* encrypted_message::mutable_source() {
  // @@protoc_insertion_point(field_mutable:encrypted_message.source)
  return _internal_mutable_source();
}
inline const std::string& encrypted_message::_internal_source() const {
  return source_.Get();
}
inline void encrypted_message::_internal_set_source(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  source_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void encrypted_message::set_source(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  source_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:encrypted_message.source)
}
inline void encrypted_message::set_source(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  source_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:encrypted_message.source)
}
inline void encrypted_message::set_source(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  source_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:encrypted_message.source)
}
inline std::string* encrypted_message::_internal_mutable_source() {
  _has_bits_[0] |= 0x00000004u;
  return source_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* encrypted_message::release_source() {
  // @@protoc_insertion_point(field_release:encrypted_message.source)
  if (!_internal_has_source()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return source_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void encrypted_message::set_allocated_source(std::string* source) {
  if (source != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  source_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), source,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:encrypted_message.source)
}
inline std::string* encrypted_message::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_unsafe_arena_release:encrypted_message.source)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000004u;
  return source_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void encrypted_message::unsafe_arena_set_allocated_source(
    std::string* source) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (source != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  source_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      source, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:encrypted_message.source)
}

// optional string destination = 4;
inline bool encrypted_message::_internal_has_destination() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool encrypted_message::has_destination() const {
  return _internal_has_destination();
}
inline void encrypted_message::clear_destination() {
  destination_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& encrypted_message::destination() const {
  // @@protoc_insertion_point(field_get:encrypted_message.destination)
  return _internal_destination();
}
inline void encrypted_message::set_destination(const std::string& value) {
  _internal_set_destination(value);
  // @@protoc_insertion_point(field_set:encrypted_message.destination)
}
inline std::string* encrypted_message::mutable_destination() {
  // @@protoc_insertion_point(field_mutable:encrypted_message.destination)
  return _internal_mutable_destination();
}
inline const std::string& encrypted_message::_internal_destination() const {
  return destination_.Get();
}
inline void encrypted_message::_internal_set_destination(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  destination_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void encrypted_message::set_destination(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  destination_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:encrypted_message.destination)
}
inline void encrypted_message::set_destination(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  destination_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:encrypted_message.destination)
}
inline void encrypted_message::set_destination(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  destination_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:encrypted_message.destination)
}
inline std::string* encrypted_message::_internal_mutable_destination() {
  _has_bits_[0] |= 0x00000008u;
  return destination_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* encrypted_message::release_destination() {
  // @@protoc_insertion_point(field_release:encrypted_message.destination)
  if (!_internal_has_destination()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return destination_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void encrypted_message::set_allocated_destination(std::string* destination) {
  if (destination != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  destination_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), destination,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:encrypted_message.destination)
}
inline std::string* encrypted_message::unsafe_arena_release_destination() {
  // @@protoc_insertion_point(field_unsafe_arena_release:encrypted_message.destination)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000008u;
  return destination_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void encrypted_message::unsafe_arena_set_allocated_destination(
    std::string* destination) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (destination != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  destination_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      destination, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:encrypted_message.destination)
}

// optional string date = 5;
inline bool encrypted_message::_internal_has_date() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool encrypted_message::has_date() const {
  return _internal_has_date();
}
inline void encrypted_message::clear_date() {
  date_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& encrypted_message::date() const {
  // @@protoc_insertion_point(field_get:encrypted_message.date)
  return _internal_date();
}
inline void encrypted_message::set_date(const std::string& value) {
  _internal_set_date(value);
  // @@protoc_insertion_point(field_set:encrypted_message.date)
}
inline std::string* encrypted_message::mutable_date() {
  // @@protoc_insertion_point(field_mutable:encrypted_message.date)
  return _internal_mutable_date();
}
inline const std::string& encrypted_message::_internal_date() const {
  return date_.Get();
}
inline void encrypted_message::_internal_set_date(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  date_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void encrypted_message::set_date(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  date_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:encrypted_message.date)
}
inline void encrypted_message::set_date(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  date_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:encrypted_message.date)
}
inline void encrypted_message::set_date(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000010u;
  date_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:encrypted_message.date)
}
inline std::string* encrypted_message::_internal_mutable_date() {
  _has_bits_[0] |= 0x00000010u;
  return date_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* encrypted_message::release_date() {
  // @@protoc_insertion_point(field_release:encrypted_message.date)
  if (!_internal_has_date()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return date_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void encrypted_message::set_allocated_date(std::string* date) {
  if (date != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  date_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), date,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:encrypted_message.date)
}
inline std::string* encrypted_message::unsafe_arena_release_date() {
  // @@protoc_insertion_point(field_unsafe_arena_release:encrypted_message.date)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000010u;
  return date_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void encrypted_message::unsafe_arena_set_allocated_date(
    std::string* date) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (date != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  date_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      date, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:encrypted_message.date)
}

// optional bytes buffer = 6;
inline bool encrypted_message::_internal_has_buffer() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool encrypted_message::has_buffer() const {
  return _internal_has_buffer();
}
inline void encrypted_message::clear_buffer() {
  buffer_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& encrypted_message::buffer() const {
  // @@protoc_insertion_point(field_get:encrypted_message.buffer)
  return _internal_buffer();
}
inline void encrypted_message::set_buffer(const std::string& value) {
  _internal_set_buffer(value);
  // @@protoc_insertion_point(field_set:encrypted_message.buffer)
}
inline std::string* encrypted_message::mutable_buffer() {
  // @@protoc_insertion_point(field_mutable:encrypted_message.buffer)
  return _internal_mutable_buffer();
}
inline const std::string& encrypted_message::_internal_buffer() const {
  return buffer_.Get();
}
inline void encrypted_message::_internal_set_buffer(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  buffer_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void encrypted_message::set_buffer(std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  buffer_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:encrypted_message.buffer)
}
inline void encrypted_message::set_buffer(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  buffer_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:encrypted_message.buffer)
}
inline void encrypted_message::set_buffer(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000020u;
  buffer_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:encrypted_message.buffer)
}
inline std::string* encrypted_message::_internal_mutable_buffer() {
  _has_bits_[0] |= 0x00000020u;
  return buffer_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* encrypted_message::release_buffer() {
  // @@protoc_insertion_point(field_release:encrypted_message.buffer)
  if (!_internal_has_buffer()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return buffer_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void encrypted_message::set_allocated_buffer(std::string* buffer) {
  if (buffer != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  buffer_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), buffer,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:encrypted_message.buffer)
}
inline std::string* encrypted_message::unsafe_arena_release_buffer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:encrypted_message.buffer)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000020u;
  return buffer_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void encrypted_message::unsafe_arena_set_allocated_buffer(
    std::string* buffer) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (buffer != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  buffer_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      buffer, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:encrypted_message.buffer)
}

// -------------------------------------------------------------------

// signature_message

// -------------------------------------------------------------------

// rsa_parameters_message

// -------------------------------------------------------------------

// ecc_parameters_message

// -------------------------------------------------------------------

// rsa_public_parameters_message

// optional bytes modulus = 1;
inline bool rsa_public_parameters_message::_internal_has_modulus() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool rsa_public_parameters_message::has_modulus() const {
  return _internal_has_modulus();
}
inline void rsa_public_parameters_message::clear_modulus() {
  modulus_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& rsa_public_parameters_message::modulus() const {
  // @@protoc_insertion_point(field_get:rsa_public_parameters_message.modulus)
  return _internal_modulus();
}
inline void rsa_public_parameters_message::set_modulus(const std::string& value) {
  _internal_set_modulus(value);
  // @@protoc_insertion_point(field_set:rsa_public_parameters_message.modulus)
}
inline std::string* rsa_public_parameters_message::mutable_modulus() {
  // @@protoc_insertion_point(field_mutable:rsa_public_parameters_message.modulus)
  return _internal_mutable_modulus();
}
inline const std::string& rsa_public_parameters_message::_internal_modulus() const {
  return modulus_.Get();
}
inline void rsa_public_parameters_message::_internal_set_modulus(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  modulus_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void rsa_public_parameters_message::set_modulus(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  modulus_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:rsa_public_parameters_message.modulus)
}
inline void rsa_public_parameters_message::set_modulus(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  modulus_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:rsa_public_parameters_message.modulus)
}
inline void rsa_public_parameters_message::set_modulus(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  modulus_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:rsa_public_parameters_message.modulus)
}
inline std::string* rsa_public_parameters_message::_internal_mutable_modulus() {
  _has_bits_[0] |= 0x00000001u;
  return modulus_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* rsa_public_parameters_message::release_modulus() {
  // @@protoc_insertion_point(field_release:rsa_public_parameters_message.modulus)
  if (!_internal_has_modulus()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return modulus_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void rsa_public_parameters_message::set_allocated_modulus(std::string* modulus) {
  if (modulus != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  modulus_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), modulus,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:rsa_public_parameters_message.modulus)
}
inline std::string* rsa_public_parameters_message::unsafe_arena_release_modulus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rsa_public_parameters_message.modulus)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return modulus_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void rsa_public_parameters_message::unsafe_arena_set_allocated_modulus(
    std::string* modulus) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (modulus != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  modulus_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      modulus, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rsa_public_parameters_message.modulus)
}

// optional bytes exponent = 2;
inline bool rsa_public_parameters_message::_internal_has_exponent() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool rsa_public_parameters_message::has_exponent() const {
  return _internal_has_exponent();
}
inline void rsa_public_parameters_message::clear_exponent() {
  exponent_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& rsa_public_parameters_message::exponent() const {
  // @@protoc_insertion_point(field_get:rsa_public_parameters_message.exponent)
  return _internal_exponent();
}
inline void rsa_public_parameters_message::set_exponent(const std::string& value) {
  _internal_set_exponent(value);
  // @@protoc_insertion_point(field_set:rsa_public_parameters_message.exponent)
}
inline std::string* rsa_public_parameters_message::mutable_exponent() {
  // @@protoc_insertion_point(field_mutable:rsa_public_parameters_message.exponent)
  return _internal_mutable_exponent();
}
inline const std::string& rsa_public_parameters_message::_internal_exponent() const {
  return exponent_.Get();
}
inline void rsa_public_parameters_message::_internal_set_exponent(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  exponent_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void rsa_public_parameters_message::set_exponent(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  exponent_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:rsa_public_parameters_message.exponent)
}
inline void rsa_public_parameters_message::set_exponent(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  exponent_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:rsa_public_parameters_message.exponent)
}
inline void rsa_public_parameters_message::set_exponent(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  exponent_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:rsa_public_parameters_message.exponent)
}
inline std::string* rsa_public_parameters_message::_internal_mutable_exponent() {
  _has_bits_[0] |= 0x00000002u;
  return exponent_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* rsa_public_parameters_message::release_exponent() {
  // @@protoc_insertion_point(field_release:rsa_public_parameters_message.exponent)
  if (!_internal_has_exponent()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return exponent_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void rsa_public_parameters_message::set_allocated_exponent(std::string* exponent) {
  if (exponent != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  exponent_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), exponent,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:rsa_public_parameters_message.exponent)
}
inline std::string* rsa_public_parameters_message::unsafe_arena_release_exponent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:rsa_public_parameters_message.exponent)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return exponent_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void rsa_public_parameters_message::unsafe_arena_set_allocated_exponent(
    std::string* exponent) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (exponent != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  exponent_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      exponent, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:rsa_public_parameters_message.exponent)
}

// -------------------------------------------------------------------

// ecc_public_parameters_message

// optional bytes p = 1;
inline bool ecc_public_parameters_message::_internal_has_p() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ecc_public_parameters_message::has_p() const {
  return _internal_has_p();
}
inline void ecc_public_parameters_message::clear_p() {
  p_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ecc_public_parameters_message::p() const {
  // @@protoc_insertion_point(field_get:ecc_public_parameters_message.p)
  return _internal_p();
}
inline void ecc_public_parameters_message::set_p(const std::string& value) {
  _internal_set_p(value);
  // @@protoc_insertion_point(field_set:ecc_public_parameters_message.p)
}
inline std::string* ecc_public_parameters_message::mutable_p() {
  // @@protoc_insertion_point(field_mutable:ecc_public_parameters_message.p)
  return _internal_mutable_p();
}
inline const std::string& ecc_public_parameters_message::_internal_p() const {
  return p_.Get();
}
inline void ecc_public_parameters_message::_internal_set_p(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  p_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ecc_public_parameters_message::set_p(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  p_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ecc_public_parameters_message.p)
}
inline void ecc_public_parameters_message::set_p(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  p_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ecc_public_parameters_message.p)
}
inline void ecc_public_parameters_message::set_p(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  p_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ecc_public_parameters_message.p)
}
inline std::string* ecc_public_parameters_message::_internal_mutable_p() {
  _has_bits_[0] |= 0x00000001u;
  return p_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ecc_public_parameters_message::release_p() {
  // @@protoc_insertion_point(field_release:ecc_public_parameters_message.p)
  if (!_internal_has_p()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return p_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ecc_public_parameters_message::set_allocated_p(std::string* p) {
  if (p != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  p_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), p,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ecc_public_parameters_message.p)
}
inline std::string* ecc_public_parameters_message::unsafe_arena_release_p() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ecc_public_parameters_message.p)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return p_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ecc_public_parameters_message::unsafe_arena_set_allocated_p(
    std::string* p) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (p != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  p_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      p, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ecc_public_parameters_message.p)
}

// -------------------------------------------------------------------

// rsa_private_parameters_message

// -------------------------------------------------------------------

// ecc_private_parameters_message

// -------------------------------------------------------------------

// curve_parameters_message

// -------------------------------------------------------------------

// hmac_parameters_message

// optional string algorithm = 1;
inline bool hmac_parameters_message::_internal_has_algorithm() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool hmac_parameters_message::has_algorithm() const {
  return _internal_has_algorithm();
}
inline void hmac_parameters_message::clear_algorithm() {
  algorithm_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& hmac_parameters_message::algorithm() const {
  // @@protoc_insertion_point(field_get:hmac_parameters_message.algorithm)
  return _internal_algorithm();
}
inline void hmac_parameters_message::set_algorithm(const std::string& value) {
  _internal_set_algorithm(value);
  // @@protoc_insertion_point(field_set:hmac_parameters_message.algorithm)
}
inline std::string* hmac_parameters_message::mutable_algorithm() {
  // @@protoc_insertion_point(field_mutable:hmac_parameters_message.algorithm)
  return _internal_mutable_algorithm();
}
inline const std::string& hmac_parameters_message::_internal_algorithm() const {
  return algorithm_.Get();
}
inline void hmac_parameters_message::_internal_set_algorithm(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  algorithm_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void hmac_parameters_message::set_algorithm(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  algorithm_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hmac_parameters_message.algorithm)
}
inline void hmac_parameters_message::set_algorithm(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  algorithm_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hmac_parameters_message.algorithm)
}
inline void hmac_parameters_message::set_algorithm(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  algorithm_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hmac_parameters_message.algorithm)
}
inline std::string* hmac_parameters_message::_internal_mutable_algorithm() {
  _has_bits_[0] |= 0x00000001u;
  return algorithm_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* hmac_parameters_message::release_algorithm() {
  // @@protoc_insertion_point(field_release:hmac_parameters_message.algorithm)
  if (!_internal_has_algorithm()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return algorithm_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void hmac_parameters_message::set_allocated_algorithm(std::string* algorithm) {
  if (algorithm != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  algorithm_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), algorithm,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hmac_parameters_message.algorithm)
}
inline std::string* hmac_parameters_message::unsafe_arena_release_algorithm() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hmac_parameters_message.algorithm)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return algorithm_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void hmac_parameters_message::unsafe_arena_set_allocated_algorithm(
    std::string* algorithm) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (algorithm != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  algorithm_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      algorithm, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hmac_parameters_message.algorithm)
}

// optional int32 size = 2;
inline bool hmac_parameters_message::_internal_has_size() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool hmac_parameters_message::has_size() const {
  return _internal_has_size();
}
inline void hmac_parameters_message::clear_size() {
  size_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 hmac_parameters_message::_internal_size() const {
  return size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 hmac_parameters_message::size() const {
  // @@protoc_insertion_point(field_get:hmac_parameters_message.size)
  return _internal_size();
}
inline void hmac_parameters_message::_internal_set_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  size_ = value;
}
inline void hmac_parameters_message::set_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:hmac_parameters_message.size)
}

// optional bytes secret = 3;
inline bool hmac_parameters_message::_internal_has_secret() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool hmac_parameters_message::has_secret() const {
  return _internal_has_secret();
}
inline void hmac_parameters_message::clear_secret() {
  secret_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& hmac_parameters_message::secret() const {
  // @@protoc_insertion_point(field_get:hmac_parameters_message.secret)
  return _internal_secret();
}
inline void hmac_parameters_message::set_secret(const std::string& value) {
  _internal_set_secret(value);
  // @@protoc_insertion_point(field_set:hmac_parameters_message.secret)
}
inline std::string* hmac_parameters_message::mutable_secret() {
  // @@protoc_insertion_point(field_mutable:hmac_parameters_message.secret)
  return _internal_mutable_secret();
}
inline const std::string& hmac_parameters_message::_internal_secret() const {
  return secret_.Get();
}
inline void hmac_parameters_message::_internal_set_secret(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  secret_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void hmac_parameters_message::set_secret(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  secret_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:hmac_parameters_message.secret)
}
inline void hmac_parameters_message::set_secret(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  secret_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:hmac_parameters_message.secret)
}
inline void hmac_parameters_message::set_secret(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  secret_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:hmac_parameters_message.secret)
}
inline std::string* hmac_parameters_message::_internal_mutable_secret() {
  _has_bits_[0] |= 0x00000002u;
  return secret_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* hmac_parameters_message::release_secret() {
  // @@protoc_insertion_point(field_release:hmac_parameters_message.secret)
  if (!_internal_has_secret()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return secret_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void hmac_parameters_message::set_allocated_secret(std::string* secret) {
  if (secret != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  secret_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), secret,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:hmac_parameters_message.secret)
}
inline std::string* hmac_parameters_message::unsafe_arena_release_secret() {
  // @@protoc_insertion_point(field_unsafe_arena_release:hmac_parameters_message.secret)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return secret_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void hmac_parameters_message::unsafe_arena_set_allocated_secret(
    std::string* secret) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (secret != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  secret_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      secret, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:hmac_parameters_message.secret)
}

// -------------------------------------------------------------------

// key_message

// optional string algorithm_type = 1;
inline bool key_message::_internal_has_algorithm_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool key_message::has_algorithm_type() const {
  return _internal_has_algorithm_type();
}
inline void key_message::clear_algorithm_type() {
  algorithm_type_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& key_message::algorithm_type() const {
  // @@protoc_insertion_point(field_get:key_message.algorithm_type)
  return _internal_algorithm_type();
}
inline void key_message::set_algorithm_type(const std::string& value) {
  _internal_set_algorithm_type(value);
  // @@protoc_insertion_point(field_set:key_message.algorithm_type)
}
inline std::string* key_message::mutable_algorithm_type() {
  // @@protoc_insertion_point(field_mutable:key_message.algorithm_type)
  return _internal_mutable_algorithm_type();
}
inline const std::string& key_message::_internal_algorithm_type() const {
  return algorithm_type_.Get();
}
inline void key_message::_internal_set_algorithm_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  algorithm_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void key_message::set_algorithm_type(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  algorithm_type_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:key_message.algorithm_type)
}
inline void key_message::set_algorithm_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  algorithm_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:key_message.algorithm_type)
}
inline void key_message::set_algorithm_type(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  algorithm_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:key_message.algorithm_type)
}
inline std::string* key_message::_internal_mutable_algorithm_type() {
  _has_bits_[0] |= 0x00000001u;
  return algorithm_type_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* key_message::release_algorithm_type() {
  // @@protoc_insertion_point(field_release:key_message.algorithm_type)
  if (!_internal_has_algorithm_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return algorithm_type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void key_message::set_allocated_algorithm_type(std::string* algorithm_type) {
  if (algorithm_type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  algorithm_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), algorithm_type,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:key_message.algorithm_type)
}
inline std::string* key_message::unsafe_arena_release_algorithm_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:key_message.algorithm_type)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return algorithm_type_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void key_message::unsafe_arena_set_allocated_algorithm_type(
    std::string* algorithm_type) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (algorithm_type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  algorithm_type_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      algorithm_type, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:key_message.algorithm_type)
}

// optional string key_name = 2;
inline bool key_message::_internal_has_key_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool key_message::has_key_name() const {
  return _internal_has_key_name();
}
inline void key_message::clear_key_name() {
  key_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& key_message::key_name() const {
  // @@protoc_insertion_point(field_get:key_message.key_name)
  return _internal_key_name();
}
inline void key_message::set_key_name(const std::string& value) {
  _internal_set_key_name(value);
  // @@protoc_insertion_point(field_set:key_message.key_name)
}
inline std::string* key_message::mutable_key_name() {
  // @@protoc_insertion_point(field_mutable:key_message.key_name)
  return _internal_mutable_key_name();
}
inline const std::string& key_message::_internal_key_name() const {
  return key_name_.Get();
}
inline void key_message::_internal_set_key_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  key_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void key_message::set_key_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  key_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:key_message.key_name)
}
inline void key_message::set_key_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  key_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:key_message.key_name)
}
inline void key_message::set_key_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  key_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:key_message.key_name)
}
inline std::string* key_message::_internal_mutable_key_name() {
  _has_bits_[0] |= 0x00000002u;
  return key_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* key_message::release_key_name() {
  // @@protoc_insertion_point(field_release:key_message.key_name)
  if (!_internal_has_key_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return key_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void key_message::set_allocated_key_name(std::string* key_name) {
  if (key_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  key_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:key_message.key_name)
}
inline std::string* key_message::unsafe_arena_release_key_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:key_message.key_name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return key_name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void key_message::unsafe_arena_set_allocated_key_name(
    std::string* key_name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (key_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  key_name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      key_name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:key_message.key_name)
}

// optional int32 key_size = 3;
inline bool key_message::_internal_has_key_size() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool key_message::has_key_size() const {
  return _internal_has_key_size();
}
inline void key_message::clear_key_size() {
  key_size_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 key_message::_internal_key_size() const {
  return key_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 key_message::key_size() const {
  // @@protoc_insertion_point(field_get:key_message.key_size)
  return _internal_key_size();
}
inline void key_message::_internal_set_key_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  key_size_ = value;
}
inline void key_message::set_key_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_key_size(value);
  // @@protoc_insertion_point(field_set:key_message.key_size)
}

// optional string purpose = 4;
inline bool key_message::_internal_has_purpose() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool key_message::has_purpose() const {
  return _internal_has_purpose();
}
inline void key_message::clear_purpose() {
  purpose_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& key_message::purpose() const {
  // @@protoc_insertion_point(field_get:key_message.purpose)
  return _internal_purpose();
}
inline void key_message::set_purpose(const std::string& value) {
  _internal_set_purpose(value);
  // @@protoc_insertion_point(field_set:key_message.purpose)
}
inline std::string* key_message::mutable_purpose() {
  // @@protoc_insertion_point(field_mutable:key_message.purpose)
  return _internal_mutable_purpose();
}
inline const std::string& key_message::_internal_purpose() const {
  return purpose_.Get();
}
inline void key_message::_internal_set_purpose(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  purpose_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void key_message::set_purpose(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  purpose_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:key_message.purpose)
}
inline void key_message::set_purpose(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  purpose_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:key_message.purpose)
}
inline void key_message::set_purpose(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  purpose_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:key_message.purpose)
}
inline std::string* key_message::_internal_mutable_purpose() {
  _has_bits_[0] |= 0x00000004u;
  return purpose_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* key_message::release_purpose() {
  // @@protoc_insertion_point(field_release:key_message.purpose)
  if (!_internal_has_purpose()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return purpose_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void key_message::set_allocated_purpose(std::string* purpose) {
  if (purpose != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  purpose_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), purpose,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:key_message.purpose)
}
inline std::string* key_message::unsafe_arena_release_purpose() {
  // @@protoc_insertion_point(field_unsafe_arena_release:key_message.purpose)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000004u;
  return purpose_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void key_message::unsafe_arena_set_allocated_purpose(
    std::string* purpose) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (purpose != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  purpose_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      purpose, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:key_message.purpose)
}

// optional string notBefore = 5;
inline bool key_message::_internal_has_notbefore() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool key_message::has_notbefore() const {
  return _internal_has_notbefore();
}
inline void key_message::clear_notbefore() {
  notbefore_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& key_message::notbefore() const {
  // @@protoc_insertion_point(field_get:key_message.notBefore)
  return _internal_notbefore();
}
inline void key_message::set_notbefore(const std::string& value) {
  _internal_set_notbefore(value);
  // @@protoc_insertion_point(field_set:key_message.notBefore)
}
inline std::string* key_message::mutable_notbefore() {
  // @@protoc_insertion_point(field_mutable:key_message.notBefore)
  return _internal_mutable_notbefore();
}
inline const std::string& key_message::_internal_notbefore() const {
  return notbefore_.Get();
}
inline void key_message::_internal_set_notbefore(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  notbefore_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void key_message::set_notbefore(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  notbefore_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:key_message.notBefore)
}
inline void key_message::set_notbefore(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  notbefore_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:key_message.notBefore)
}
inline void key_message::set_notbefore(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  notbefore_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:key_message.notBefore)
}
inline std::string* key_message::_internal_mutable_notbefore() {
  _has_bits_[0] |= 0x00000008u;
  return notbefore_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* key_message::release_notbefore() {
  // @@protoc_insertion_point(field_release:key_message.notBefore)
  if (!_internal_has_notbefore()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return notbefore_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void key_message::set_allocated_notbefore(std::string* notbefore) {
  if (notbefore != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  notbefore_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), notbefore,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:key_message.notBefore)
}
inline std::string* key_message::unsafe_arena_release_notbefore() {
  // @@protoc_insertion_point(field_unsafe_arena_release:key_message.notBefore)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000008u;
  return notbefore_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void key_message::unsafe_arena_set_allocated_notbefore(
    std::string* notbefore) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (notbefore != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  notbefore_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      notbefore, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:key_message.notBefore)
}

// optional string notAfter = 6;
inline bool key_message::_internal_has_notafter() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool key_message::has_notafter() const {
  return _internal_has_notafter();
}
inline void key_message::clear_notafter() {
  notafter_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& key_message::notafter() const {
  // @@protoc_insertion_point(field_get:key_message.notAfter)
  return _internal_notafter();
}
inline void key_message::set_notafter(const std::string& value) {
  _internal_set_notafter(value);
  // @@protoc_insertion_point(field_set:key_message.notAfter)
}
inline std::string* key_message::mutable_notafter() {
  // @@protoc_insertion_point(field_mutable:key_message.notAfter)
  return _internal_mutable_notafter();
}
inline const std::string& key_message::_internal_notafter() const {
  return notafter_.Get();
}
inline void key_message::_internal_set_notafter(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  notafter_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void key_message::set_notafter(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  notafter_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:key_message.notAfter)
}
inline void key_message::set_notafter(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  notafter_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:key_message.notAfter)
}
inline void key_message::set_notafter(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000010u;
  notafter_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:key_message.notAfter)
}
inline std::string* key_message::_internal_mutable_notafter() {
  _has_bits_[0] |= 0x00000010u;
  return notafter_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* key_message::release_notafter() {
  // @@protoc_insertion_point(field_release:key_message.notAfter)
  if (!_internal_has_notafter()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return notafter_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void key_message::set_allocated_notafter(std::string* notafter) {
  if (notafter != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  notafter_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), notafter,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:key_message.notAfter)
}
inline std::string* key_message::unsafe_arena_release_notafter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:key_message.notAfter)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000010u;
  return notafter_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void key_message::unsafe_arena_set_allocated_notafter(
    std::string* notafter) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (notafter != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  notafter_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      notafter, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:key_message.notAfter)
}

// optional bytes secret = 7;
inline bool key_message::_internal_has_secret() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool key_message::has_secret() const {
  return _internal_has_secret();
}
inline void key_message::clear_secret() {
  secret_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& key_message::secret() const {
  // @@protoc_insertion_point(field_get:key_message.secret)
  return _internal_secret();
}
inline void key_message::set_secret(const std::string& value) {
  _internal_set_secret(value);
  // @@protoc_insertion_point(field_set:key_message.secret)
}
inline std::string* key_message::mutable_secret() {
  // @@protoc_insertion_point(field_mutable:key_message.secret)
  return _internal_mutable_secret();
}
inline const std::string& key_message::_internal_secret() const {
  return secret_.Get();
}
inline void key_message::_internal_set_secret(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  secret_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void key_message::set_secret(std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  secret_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:key_message.secret)
}
inline void key_message::set_secret(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  secret_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:key_message.secret)
}
inline void key_message::set_secret(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000020u;
  secret_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:key_message.secret)
}
inline std::string* key_message::_internal_mutable_secret() {
  _has_bits_[0] |= 0x00000020u;
  return secret_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* key_message::release_secret() {
  // @@protoc_insertion_point(field_release:key_message.secret)
  if (!_internal_has_secret()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return secret_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void key_message::set_allocated_secret(std::string* secret) {
  if (secret != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  secret_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), secret,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:key_message.secret)
}
inline std::string* key_message::unsafe_arena_release_secret() {
  // @@protoc_insertion_point(field_unsafe_arena_release:key_message.secret)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000020u;
  return secret_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void key_message::unsafe_arena_set_allocated_secret(
    std::string* secret) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (secret != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  secret_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      secret, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:key_message.secret)
}

// -------------------------------------------------------------------

// scheme_message

// optional string scheme_type = 1;
inline bool scheme_message::_internal_has_scheme_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool scheme_message::has_scheme_type() const {
  return _internal_has_scheme_type();
}
inline void scheme_message::clear_scheme_type() {
  scheme_type_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& scheme_message::scheme_type() const {
  // @@protoc_insertion_point(field_get:scheme_message.scheme_type)
  return _internal_scheme_type();
}
inline void scheme_message::set_scheme_type(const std::string& value) {
  _internal_set_scheme_type(value);
  // @@protoc_insertion_point(field_set:scheme_message.scheme_type)
}
inline std::string* scheme_message::mutable_scheme_type() {
  // @@protoc_insertion_point(field_mutable:scheme_message.scheme_type)
  return _internal_mutable_scheme_type();
}
inline const std::string& scheme_message::_internal_scheme_type() const {
  return scheme_type_.Get();
}
inline void scheme_message::_internal_set_scheme_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  scheme_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void scheme_message::set_scheme_type(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  scheme_type_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:scheme_message.scheme_type)
}
inline void scheme_message::set_scheme_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  scheme_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:scheme_message.scheme_type)
}
inline void scheme_message::set_scheme_type(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  scheme_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:scheme_message.scheme_type)
}
inline std::string* scheme_message::_internal_mutable_scheme_type() {
  _has_bits_[0] |= 0x00000001u;
  return scheme_type_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* scheme_message::release_scheme_type() {
  // @@protoc_insertion_point(field_release:scheme_message.scheme_type)
  if (!_internal_has_scheme_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return scheme_type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void scheme_message::set_allocated_scheme_type(std::string* scheme_type) {
  if (scheme_type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  scheme_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), scheme_type,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:scheme_message.scheme_type)
}
inline std::string* scheme_message::unsafe_arena_release_scheme_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:scheme_message.scheme_type)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return scheme_type_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void scheme_message::unsafe_arena_set_allocated_scheme_type(
    std::string* scheme_type) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (scheme_type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  scheme_type_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      scheme_type, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:scheme_message.scheme_type)
}

// optional .key_message encryption_key = 2;
inline bool scheme_message::_internal_has_encryption_key() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || encryption_key_ != nullptr);
  return value;
}
inline bool scheme_message::has_encryption_key() const {
  return _internal_has_encryption_key();
}
inline void scheme_message::clear_encryption_key() {
  if (encryption_key_ != nullptr) encryption_key_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::key_message& scheme_message::_internal_encryption_key() const {
  const ::key_message* p = encryption_key_;
  return p != nullptr ? *p : *reinterpret_cast<const ::key_message*>(
      &::_key_message_default_instance_);
}
inline const ::key_message& scheme_message::encryption_key() const {
  // @@protoc_insertion_point(field_get:scheme_message.encryption_key)
  return _internal_encryption_key();
}
inline void scheme_message::unsafe_arena_set_allocated_encryption_key(
    ::key_message* encryption_key) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(encryption_key_);
  }
  encryption_key_ = encryption_key;
  if (encryption_key) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:scheme_message.encryption_key)
}
inline ::key_message* scheme_message::release_encryption_key() {
  auto temp = unsafe_arena_release_encryption_key();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::key_message* scheme_message::unsafe_arena_release_encryption_key() {
  // @@protoc_insertion_point(field_release:scheme_message.encryption_key)
  _has_bits_[0] &= ~0x00000004u;
  ::key_message* temp = encryption_key_;
  encryption_key_ = nullptr;
  return temp;
}
inline ::key_message* scheme_message::_internal_mutable_encryption_key() {
  _has_bits_[0] |= 0x00000004u;
  if (encryption_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::key_message>(GetArena());
    encryption_key_ = p;
  }
  return encryption_key_;
}
inline ::key_message* scheme_message::mutable_encryption_key() {
  // @@protoc_insertion_point(field_mutable:scheme_message.encryption_key)
  return _internal_mutable_encryption_key();
}
inline void scheme_message::set_allocated_encryption_key(::key_message* encryption_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete encryption_key_;
  }
  if (encryption_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(encryption_key);
    if (message_arena != submessage_arena) {
      encryption_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, encryption_key, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  encryption_key_ = encryption_key;
  // @@protoc_insertion_point(field_set_allocated:scheme_message.encryption_key)
}

// optional .hmac_parameters_message parameters = 3;
inline bool scheme_message::_internal_has_parameters() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || parameters_ != nullptr);
  return value;
}
inline bool scheme_message::has_parameters() const {
  return _internal_has_parameters();
}
inline void scheme_message::clear_parameters() {
  if (parameters_ != nullptr) parameters_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::hmac_parameters_message& scheme_message::_internal_parameters() const {
  const ::hmac_parameters_message* p = parameters_;
  return p != nullptr ? *p : *reinterpret_cast<const ::hmac_parameters_message*>(
      &::_hmac_parameters_message_default_instance_);
}
inline const ::hmac_parameters_message& scheme_message::parameters() const {
  // @@protoc_insertion_point(field_get:scheme_message.parameters)
  return _internal_parameters();
}
inline void scheme_message::unsafe_arena_set_allocated_parameters(
    ::hmac_parameters_message* parameters) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parameters_);
  }
  parameters_ = parameters;
  if (parameters) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:scheme_message.parameters)
}
inline ::hmac_parameters_message* scheme_message::release_parameters() {
  auto temp = unsafe_arena_release_parameters();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::hmac_parameters_message* scheme_message::unsafe_arena_release_parameters() {
  // @@protoc_insertion_point(field_release:scheme_message.parameters)
  _has_bits_[0] &= ~0x00000008u;
  ::hmac_parameters_message* temp = parameters_;
  parameters_ = nullptr;
  return temp;
}
inline ::hmac_parameters_message* scheme_message::_internal_mutable_parameters() {
  _has_bits_[0] |= 0x00000008u;
  if (parameters_ == nullptr) {
    auto* p = CreateMaybeMessage<::hmac_parameters_message>(GetArena());
    parameters_ = p;
  }
  return parameters_;
}
inline ::hmac_parameters_message* scheme_message::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable:scheme_message.parameters)
  return _internal_mutable_parameters();
}
inline void scheme_message::set_allocated_parameters(::hmac_parameters_message* parameters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete parameters_;
  }
  if (parameters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(parameters);
    if (message_arena != submessage_arena) {
      parameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parameters, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  parameters_ = parameters;
  // @@protoc_insertion_point(field_set_allocated:scheme_message.parameters)
}

// optional bytes public_nonce = 4;
inline bool scheme_message::_internal_has_public_nonce() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool scheme_message::has_public_nonce() const {
  return _internal_has_public_nonce();
}
inline void scheme_message::clear_public_nonce() {
  public_nonce_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& scheme_message::public_nonce() const {
  // @@protoc_insertion_point(field_get:scheme_message.public_nonce)
  return _internal_public_nonce();
}
inline void scheme_message::set_public_nonce(const std::string& value) {
  _internal_set_public_nonce(value);
  // @@protoc_insertion_point(field_set:scheme_message.public_nonce)
}
inline std::string* scheme_message::mutable_public_nonce() {
  // @@protoc_insertion_point(field_mutable:scheme_message.public_nonce)
  return _internal_mutable_public_nonce();
}
inline const std::string& scheme_message::_internal_public_nonce() const {
  return public_nonce_.Get();
}
inline void scheme_message::_internal_set_public_nonce(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  public_nonce_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void scheme_message::set_public_nonce(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  public_nonce_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:scheme_message.public_nonce)
}
inline void scheme_message::set_public_nonce(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  public_nonce_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:scheme_message.public_nonce)
}
inline void scheme_message::set_public_nonce(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  public_nonce_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:scheme_message.public_nonce)
}
inline std::string* scheme_message::_internal_mutable_public_nonce() {
  _has_bits_[0] |= 0x00000002u;
  return public_nonce_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* scheme_message::release_public_nonce() {
  // @@protoc_insertion_point(field_release:scheme_message.public_nonce)
  if (!_internal_has_public_nonce()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return public_nonce_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void scheme_message::set_allocated_public_nonce(std::string* public_nonce) {
  if (public_nonce != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  public_nonce_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), public_nonce,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:scheme_message.public_nonce)
}
inline std::string* scheme_message::unsafe_arena_release_public_nonce() {
  // @@protoc_insertion_point(field_unsafe_arena_release:scheme_message.public_nonce)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return public_nonce_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void scheme_message::unsafe_arena_set_allocated_public_nonce(
    std::string* public_nonce) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (public_nonce != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  public_nonce_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      public_nonce, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:scheme_message.public_nonce)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_support_2eproto
