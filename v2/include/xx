// Background
//  The elliptic curve EC(p, a, b) is the set of points (x,y) with y^2= x^3+ax+b
//  plus a point at infinity, denoted by O.  Usually, we assume the right hand
//  side of the equation defining EC(p, a, b) does not have repeated roots.
//  p is an odd prime.
//  To add two points P1 and P2, first check to see if one of them, say, P2 is O,
//  then P1 + P2 = P1.  Otherwise, P1 = (x1, y1) and P2= (x2,y2).
//  Calculate m as follows:
//    If P1 != P2, m = (y2-y1)/(x2-x1).
//    If P1=P2, m= (3x1^2+b)/(2y1).
//  In either case, if denominator used in claculating m is 0, P1+P2=O, otherwise,
//    P3=(x3,y3), x3 = m^2-x1-x2, y3 = m(x1-x3)-y1. All calculations mod p.
//  Hasse: If N is the number of point on EC(p, a, b), |N-p-1| < 2sqrt(p).
//  To embed an n bit  message m in a point, M, shift m by k bits, where
//  n + k > size of p. Denote the shifted message by x.  Check to see if
//  x^3+ax+b is a square, if so, calculate its square root as y.  M=(x,y).
//  If x^3+ax+b is not a square, change the bottom k bits of x until you obtain
//  a square.  To extract a message from (x, y), just shift x k bits.
//
//  ECC
//    Given EC(p, a, b) and a point B on EC(p, a, b), private key holder picks
//    a secret 0 <= sA < p uniformly at random.  Public key is EC(p, a, b), B,
//    P, where P=(secret)B.
//  ECC encrypt
//    Sender picks a secret, sB, 0 <= sB < p.  You should never reuse sB.
//    Sender embeds his message in a point M and calculates (sB)B and (sB)P.
//    Encrypted message is [(sB)B, M+(sB)P].
//  ECC decrypt
//    Receiver gets message D = [Q, R].  He calculates M= R - (sA)Q and extracts
//    m form M.
//  ECC sign(m).  Public, private keys are the same as in ECC.
//    Pick an unreuseable nonce, sS, 0 <= sS < N.  Make sure sS has an inverse
//    mod N.
//    Compute Q= (sS)B = (x,y).
//    Compute s= (sS^(-1))(m-sAx) (mod N).
//    Send [m, Q, s]
//  ECC verify
//    Compute v1 = xB + sQ and v2 = mA.  Accept signature if v1 == v2.

